=== {learning-goals}

// tag::DE[]
[[LZ-3-1]]
==== LZ 3-1: Dies ist das erste Lernziel in Kapitel 3, das mit xyz

Hier wird beschrieben, was Teilnehmer:innen in diesem Lernziel lernen sollen. Das kann in Prosa-Text
in ganzen Sätzen oder in Aufzählungen mit Unterpunkten erfolgen. Dabei kann auch unterschieden werden,
wie wichtig einzelne Aspekte des Lernziels sind. Es kann hier bereits auf Literatur verwiesen werden.

* Erstes Teilziel
* Zweites Unterthema
* Dritter Aspekt

[[LZ-3-2]]
==== LZ 3-2: Hier ist ein zweites Lernziel in diesem Kapitel
tbd.

// end::DE[]

// tag::EN[]
[[LG-3-1]]
==== LG 3-1: Applicability

* Know that not all parts of a typical software system are
  susceptible to formal methods.

* Know taxonomies like the SPE model that classify software according
  to their degree of precise specification, and to use the taxomonies
  for identifying the parts of a software system amenable to formal
  methods.

[[LG-3-2]]
==== LG 3-2: Relevant Qualities

* Know the qualities that typically indicate the use of formal
  methods, such as reliability, safety, and security.

[[LG-3-3]]
==== LG 3-3: Relevance Specification

* Know that the successful application of formal methods
  depends on the precise specification of the properties they require
  the software system to exhibit.

[[LG-3-4]]
==== LG 3-4: Tradeoffs

Know the tradeoffs inherent in the choice of a particular formal
method, in particular with respect to:

* expressiveness of its specification formalism
* effort needed to assist the formal method in establishing the
  desired result
* the qualificiations required of those who apply the method.

[[LG-3-5]]
==== LG 3-5: Gradual Introduction

* Know techniques for gradually introducing formal methods into a
  software project such as adding static typing or property-based
  testing.

[[LG-3-6]]
==== LG 3-6: Appropriate Selection of Methods

Be able to choose an appropriate formal method depending on the
form of the specification such as:

* use (probalistic) model checking for specifications of state
  machines
* use SMT/SAT solving for constraint systems
* abstract interpretation for technical properties of the code
* abstract interpretation for properties of the technical architecture
* proof assistants for more general specifications

(See section <<Tools>>.)

// end::EN[]
